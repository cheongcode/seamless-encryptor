{"version":3,"file":"main.js","mappings":";;;;;;;;;AAAA,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,iEAA8B;AAC1C,YAAY,mBAAO,CAAC,uFAAO;AAC3B,UAAU,qDAAuB;;AAEjC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;;AAEA,UAAU,+HAAmC;AAC7C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,qBAAqB;AAC3B;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,qHAAgC;;AAEhC;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;;AAEA,EAAE,aAAa;AACf,EAAE,aAAa;;AAEf;AACA;;AAEA,kBAAkB,SAAS;AAC3B,6BAA6B;AAC7B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACzMA;AACA;AACA;AACA;;AAEA;AACA,EAAE,sIAAwC;AAC1C,EAAE;AACF,EAAE,gIAAqC;AACvC;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,UAAU,+HAAmC;AAC7C,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;;AAEjB;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,cAAI;AAC3B,4CAA4C,kBAAkB;AAC9D;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,gBAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACvPA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACRA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;;;;;UCCA;;;;;;;;;ACDA,QAAQ,6CAA6C,EAAE,mBAAO,CAAC,0BAAU;AACzE,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iDAAQ,UAAU,CAAC;AACtC,kCAAkC,WAAW;AAC7C;AACA;AACA,IAAI;AACJ,4CAA4C,WAAW;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,yDAAyD;;AAEzD,QAAQ,qBAAqB,6CAA6C;;AAE1E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,mBAAO,CAAC,oFAA2B;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iDAAQ,MAAM,CAAC;AAC5B,MAAM;AACN,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,IAAwD;AAChE,oBAAoB,2FAAiC;AACrD;AACA,MAAM,KAAK,EAIN;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,IAAgD;AACxD,iBAAiB,mCAAyB;AAC1C;AACA,MAAM,KAAK,EAIN;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,0CAA0C,cAAc;AACxD;AACA;;AAEA;AACA;AACA;AACA,0EAA0E,OAAO;AACjF;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe,0CAA0C,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,eAAe,8CAA8C,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,QAAQ;AACR;AACA,iBAAiB,4CAA4C,qBAAqB;AAClF;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+CAA+C,OAAO;AACtD,iBAAiB,4CAA4C,qBAAqB;AAClF;AACA,MAAM;AACN,eAAe,yDAAyD,OAAO;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA,8DAA8D,OAAO,GAAG,SAAS;AACjF;AACA;AACA;AACA,MAAM;AACN;AACA,eAAe,uDAAuD,mBAAmB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,gDAAgD,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,sBAAsB;AACzF;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS,IAAI,sBAAsB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA,MAAM;AACN;AACA,eAAe,8CAA8C,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU,aAAa,SAAS,cAAc,UAAU;AAC/G,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,eAAe,wDAAwD,mBAAmB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR,iBAAiB,iDAAiD,UAAU;AAC5E;AACA,MAAM;AACN;AACA,eAAe,6CAA6C,qBAAqB;AACjF;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,eAAe,uDAAuD,mBAAmB;AACzF;AACA,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED,gDAAgD,kBAAkB;AAClE;AACA;AACA,iDAAiD,6CAA6C;AAC9F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,OAAO,GAAG,SAAS;AACjD,+BAA+B,OAAO;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,iDAAiD,uDAAuD;AACxG;;AAEA;AACA,iDAAiD,8CAA8C,2BAA2B,MAAM;AAChI;;AAEA;AACA,iDAAiD,wCAAwC;AACzF;AACA;AACA,wBAAwB,sCAAsC;AAC9D,SAAS;;AAET;AACA,qBAAqB;AACrB;;AAEA;AACA,iDAAiD,6CAA6C;;AAE9F,iBAAiB;AACjB,MAAM;AACN;AACA,iBAAiB;AACjB;AACA,CAAC;;AAED;AACA,0DAA0D,kBAAkB;AAC5E;AACA;AACA,iDAAiD,6CAA6C;AAC9F;AACA;AACA,8BAA8B,OAAO,GAAG,SAAS;AACjD,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,iDAAiD,uDAAuD;AACxG;;AAEA;AACA,iDAAiD,wCAAwC;AACzF;AACA,4BAA4B,SAAS,GAAG,UAAU;AAClD,wBAAwB,oDAAoD;AAC5E,SAAS;;AAET;AACA,qBAAqB;AACrB;;AAEA;AACA,iDAAiD,6CAA6C;;AAE9F,iBAAiB;AACjB,MAAM;AACN;AACA,iBAAiB;AACjB;AACA,CAAC;;AAED;AACA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO,GAAG,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,uDAAuD,OAAO,IAAI,YAAY;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,UAAU;AACV;AACA,mBAAmB,yCAAyC,qBAAqB;AACjF;AACA;AACA,MAAM;AACN;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC;AACnC,iBAAiB;AACjB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,MAAM;AACN,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,GAAG;AACH;AACA,2EAA2E,yBAAyB;AACpG;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU,GAAG,wBAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ,kEAAkE,cAAc;AAChF;AACA;AACA,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC","sources":["webpack://seamless-encryptor/./node_modules/electron-squirrel-startup/index.js","webpack://seamless-encryptor/./node_modules/electron-squirrel-startup/node_modules/debug/src/browser.js","webpack://seamless-encryptor/./node_modules/electron-squirrel-startup/node_modules/debug/src/debug.js","webpack://seamless-encryptor/./node_modules/electron-squirrel-startup/node_modules/debug/src/index.js","webpack://seamless-encryptor/./node_modules/electron-squirrel-startup/node_modules/debug/src/node.js","webpack://seamless-encryptor/./node_modules/electron-squirrel-startup/node_modules/ms/index.js","webpack://seamless-encryptor/./src/main/ sync","webpack://seamless-encryptor/external node-commonjs \"child_process\"","webpack://seamless-encryptor/external node-commonjs \"crypto\"","webpack://seamless-encryptor/external commonjs2 \"electron\"","webpack://seamless-encryptor/external node-commonjs \"fs\"","webpack://seamless-encryptor/external node-commonjs \"net\"","webpack://seamless-encryptor/external node-commonjs \"path\"","webpack://seamless-encryptor/external node-commonjs \"tty\"","webpack://seamless-encryptor/external node-commonjs \"util\"","webpack://seamless-encryptor/webpack/bootstrap","webpack://seamless-encryptor/webpack/runtime/hasOwnProperty shorthand","webpack://seamless-encryptor/webpack/runtime/compat","webpack://seamless-encryptor/./src/main/main.js"],"sourcesContent":["var path = require('path');\nvar spawn = require('child_process').spawn;\nvar debug = require('debug')('electron-squirrel-startup');\nvar app = require('electron').app;\n\nvar run = function(args, done) {\n  var updateExe = path.resolve(path.dirname(process.execPath), '..', 'Update.exe');\n  debug('Spawning `%s` with args `%s`', updateExe, args);\n  spawn(updateExe, args, {\n    detached: true\n  }).on('close', done);\n};\n\nvar check = function() {\n  if (process.platform === 'win32') {\n    var cmd = process.argv[1];\n    debug('processing squirrel command `%s`', cmd);\n    var target = path.basename(process.execPath);\n\n    if (cmd === '--squirrel-install' || cmd === '--squirrel-updated') {\n      run(['--createShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-uninstall') {\n      run(['--removeShortcut=' + target + ''], app.quit);\n      return true;\n    }\n    if (cmd === '--squirrel-obsolete') {\n      app.quit();\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = check();\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/main sync recursive\";\nmodule.exports = webpackEmptyContext;","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"electron\");","module.exports = require(\"fs\");","module.exports = require(\"net\");","module.exports = require(\"path\");","module.exports = require(\"tty\");","module.exports = require(\"util\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\nif (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + \"/native_modules/\";","const { app, BrowserWindow, ipcMain, dialog, shell } = require('electron');\nconst path = require('path');\nconst fs = require('fs');\nconst crypto = require('crypto');\n\n// Import utility modules\nconst moduleCache = {};\n\n/**\n * Safely require a module with fallback implementation\n * @param {string} modulePath - Path to the module\n * @param {Object} fallback - Fallback implementation if module cannot be loaded\n * @returns {Object} The loaded module or fallback\n */\nfunction safeRequire(modulePath, fallback) {\n  try {\n    if (moduleCache[modulePath]) {\n      return moduleCache[modulePath];\n    }\n    \n    const module = require(modulePath);\n    console.log(`Loaded module: ${modulePath}`);\n    moduleCache[modulePath] = module;\n    return module;\n  } catch (err) {\n    console.error(`Failed to load module: ${modulePath}`, err.message);\n    return fallback;\n  }\n}\n\n// Load required modules with fallbacks\nconst keyManager = safeRequire('../config/keyManager', {\n  getKey: async () => {\n    try {\n      return encryptionKey || null;\n    } catch (error) {\n      console.error('Error in keyManager.getKey:', error);\n      return null;\n    }\n  },\n  setKey: async (key) => {\n    try {\n      global.encryptionKey = key;\n      return true;\n    } catch (error) {\n      console.error('Error in keyManager.setKey:', error);\n      return false;\n    }\n  },\n  getMasterKey: async () => global.encryptionKey || null\n});\n\nconst encryptionMethods = safeRequire('../crypto/encryptionMethods', {\n  encrypt: async (data, key, algorithm = 'aes-256-gcm') => {\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n    const authTag = cipher.getAuthTag();\n    return {\n      algorithm: 'aes-256-gcm',\n      encryptedData: Buffer.concat([iv, authTag, encrypted])\n    };\n  },\n  decrypt: async ({ encryptedData, algorithm }, key) => {\n    const iv = encryptedData.slice(0, 16);\n    const authTag = encryptedData.slice(16, 32);\n    const encrypted = encryptedData.slice(32);\n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);\n    decipher.setAuthTag(authTag);\n    return Buffer.concat([decipher.update(encrypted), decipher.final()]);\n  },\n  getAllEncryptionMethods: () => ['aes-256-gcm'],\n  getEncryptionMethod: () => 'aes-256-gcm',\n  setEncryptionMethod: () => true\n});\n\nconst entropyAnalyzer = safeRequire('../crypto/entropyAnalyzer', {\n  calculateEntropy: (data) => {\n    // Simple entropy calculation fallback\n    if (!data || data.length === 0) return 0;\n    const freqs = new Array(256).fill(0);\n    for (let i = 0; i < data.length; i++) freqs[data[i]]++;\n    let entropy = 0;\n    for (let i = 0; i < 256; i++) {\n      if (freqs[i] > 0) {\n        const p = freqs[i] / data.length;\n        entropy -= p * (Math.log(p) / Math.log(2));\n      }\n    }\n    return entropy;\n  },\n  analyzeEntropyInChunks: (data) => ({\n    overallEntropy: entropyAnalyzer.calculateEntropy(data),\n    rating: 'Analysis Limited',\n    isGoodEncryption: null\n  })\n});\n\nconst cryptoUtil = safeRequire('../crypto/cryptoUtil', {});\n\nconst { analyzeFileEntropy } = safeRequire('../crypto/entropyAnalyzer', {});\n\n// Global variables\nlet mainWindow;\nlet encryptionKey = null;\n\n// App initialization\nconsole.log('ðŸ“‚ App path:', app.getAppPath());\nconsole.log('ðŸ“ User data path:', app.getPath('userData'));\n\n// Handle creating/removing shortcuts on Windows when installing/uninstalling\nif (require('electron-squirrel-startup')) {\n  app.quit();\n}\n\nfunction createWindow() {\n  console.log('[main.js] Starting createWindow function...');\n  \n  // Safely load optional dependencies\n  const safeRequire = (module) => {\n    try {\n      return require(module);\n    } catch (e) {\n      console.warn(`[main.js] Could not load module: ${module}`, e.message);\n      return null;\n    }\n  };\n\n  // Define paths\n  const APP_PATH = app.getAppPath();\n  console.log('[main.js] App path:', APP_PATH);\n\n  // Determine preload script path\n  let preloadPath;\n  try {\n    if (typeof MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY !== 'undefined') {\n      preloadPath = MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY;\n      console.log('[main.js] Using webpack preload path:', preloadPath);\n    } else {\n      // Fallback to directly finding the preload script\n      preloadPath = path.join(APP_PATH, 'preload.js');\n      console.log('[main.js] Using fallback preload path:', preloadPath);\n    }\n  } catch (error) {\n    // Ultimate fallback\n    preloadPath = path.join(APP_PATH, 'preload.js');\n    console.log('[main.js] Using ultimate fallback preload path:', preloadPath);\n  }\n\n  // Create the browser window\n  try {\n    mainWindow = new BrowserWindow({\n      width: 1024,\n      height: 768,\n      webPreferences: {\n        nodeIntegration: false,\n        contextIsolation: true,\n        preload: preloadPath,\n        sandbox: true,\n        webSecurity: true\n      },\n    });\n    console.log('[main.js] Browser window created successfully.');\n  } catch (error) {\n    console.error('[main.js] Failed to create browser window:', error.message);\n    return;\n  }\n\n  // Determine HTML path\n  let htmlPath;\n  try {\n    if (typeof MAIN_WINDOW_WEBPACK_ENTRY !== 'undefined') {\n      htmlPath = MAIN_WINDOW_WEBPACK_ENTRY;\n      console.log('[main.js] Using webpack HTML entry point:', htmlPath);\n    } else {\n      // Fallback to direct HTML file\n      htmlPath = 'file://' + path.join(APP_PATH, 'src/renderer/index.html');\n      console.log('[main.js] Using fallback HTML path:', htmlPath);\n    }\n  } catch (error) {\n    // Ultimate fallback\n    htmlPath = 'file://' + path.join(APP_PATH, 'src/renderer/index.html');\n    console.log('[main.js] Using ultimate fallback HTML path:', htmlPath);\n  }\n\n  // Load the HTML\n  try {\n    console.log('[main.js] Loading HTML from:', htmlPath);\n    mainWindow.loadURL(htmlPath);\n  } catch (error) {\n    console.error('[main.js] Failed to load HTML:', error.message);\n    // Try a simpler approach if the first attempt fails\n    try {\n      const simplePath = 'file://' + path.join(APP_PATH, 'src/renderer/index.html');\n      console.log('[main.js] Trying simpler HTML path:', simplePath);\n      mainWindow.loadFile(path.join(APP_PATH, 'src/renderer/index.html'));\n    } catch (innerError) {\n      console.error('[main.js] Also failed with simpler path:', innerError.message);\n    }\n  }\n\n  // Open DevTools for debugging\n  mainWindow.webContents.openDevTools();\n\n  // Log when content loads or fails\n  mainWindow.webContents.on('did-finish-load', () => {\n    console.log('[main.js] Content finished loading successfully.');\n  });\n\n  mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription) => {\n    console.error('[main.js] Content failed to load:', errorCode, errorDescription);\n  });\n\n  // Handle window being closed\n  mainWindow.on('closed', function () {\n    console.log('[main.js] Window closed event triggered.');\n    mainWindow = null;\n  });\n\n  console.log('[main.js] Window creation complete.');\n}\n\n// Storage service for saving encrypted files\nconst storageService = {\n  uploadFile: async (key, data) => {\n    // For now, just save to the app's user data folder\n    const storageDir = path.join(app.getPath('userData'), 'encrypted');\n    \n    // Create base directory if needed\n    if (!fs.existsSync(storageDir)) {\n      fs.mkdirSync(storageDir, { recursive: true });\n    }\n    \n    // Create subdirectory for this file\n    const keyParts = key.split('/');\n    if (keyParts.length > 1) {\n      const dirPart = path.join(storageDir, keyParts[0]);\n      if (!fs.existsSync(dirPart)) {\n        fs.mkdirSync(dirPart, { recursive: true });\n      }\n    }\n    \n    const filePath = path.join(storageDir, key);\n    await fs.promises.writeFile(filePath, data);\n    return { key };\n  },\n  \n  downloadFile: async (key) => {\n    const storageDir = path.join(app.getPath('userData'), 'encrypted');\n    const filePath = path.join(storageDir, key);\n    \n    if (fs.existsSync(filePath)) {\n      return await fs.promises.readFile(filePath);\n    }\n    throw new Error('File not found');\n  },\n  \n  deleteFile: async (key) => {\n    const storageDir = path.join(app.getPath('userData'), 'encrypted');\n    const filePath = path.join(storageDir, key);\n    \n    if (fs.existsSync(filePath)) {\n      await fs.promises.unlink(filePath);\n      return true;\n    }\n    return false;\n  }\n};\n\n// Helper function to decrypt data\nasync function decryptData(encryptedData, encryptionKey, algorithm) {\n  try {\n    const key = Buffer.from(encryptionKey, 'hex');\n    \n    // If an algorithm is specified, use it for decryption\n    if (algorithm) {\n      return await encryptionMethods.decrypt({ encryptedData, algorithm }, key);\n    }\n    \n    // Legacy format (AES-256-GCM without algorithm tag)\n    const iv = encryptedData.slice(0, 16);\n    const authTag = encryptedData.slice(16, 32);\n    const encrypted = encryptedData.slice(32);\n    \n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, iv);\n    decipher.setAuthTag(authTag);\n    \n    return Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final()\n    ]);\n  } catch (error) {\n    console.error('Decryption failed:', error);\n    throw new Error(`Decryption failed: ${error.message}`);\n  }\n}\n\n// IPC Handlers\nipcMain.handle('encrypt-file', async (event, filePath, method = 'aes-256-gcm') => {\n  try {\n    console.log(`encrypt-file handler called with:`, filePath, `method: ${method}`);\n    \n    // Input validation\n    if (!filePath) {\n      return { success: false, error: 'No file path provided' };\n    }\n    \n    // If filePath is an array, take the first item (backward compatibility)\n    if (Array.isArray(filePath)) {\n      console.log('filePath is an array, taking the first item:', filePath[0]);\n      filePath = filePath[0];\n    }\n    \n    // If filePath is an object with a filePath property, extract it (backward compatibility)\n    if (typeof filePath === 'object' && filePath !== null && filePath.filePath) {\n      console.log('filePath is an object, extracting filePath property:', filePath.filePath);\n      if (Array.isArray(filePath.filePath) && filePath.filePath.length > 0) {\n        filePath = filePath.filePath[0];\n      } else {\n        filePath = filePath.filePath;\n      }\n    }\n    \n    // Last check to ensure filePath is a string\n    if (typeof filePath !== 'string') {\n      console.error('Invalid filePath format:', filePath);\n      return { success: false, error: 'Invalid file path format' };\n    }\n    \n    console.log(`Processing file: ${filePath}`);\n    \n    // Validate the encryption method\n    const supportedMethods = ['aes-256-gcm', 'chacha20-poly1305', 'xchacha20-poly1305'];\n    if (!method || !supportedMethods.includes(method)) {\n      console.warn(`Unsupported encryption method: ${method}, defaulting to aes-256-gcm`);\n      method = 'aes-256-gcm';\n    }\n    \n    // Get encryption key - First check the global variable which should be set by generate-key\n    let key = encryptionKey;\n    console.log('Using encryption key exists:', !!key);\n    \n    // If no key in global variable, try to get from key manager\n    if (!key && keyManager) {\n      try {\n        if (typeof keyManager.getKey === 'function') {\n          key = await keyManager.getKey();\n          console.log('Retrieved key from keyManager.getKey()');\n        } else if (typeof keyManager.getMasterKey === 'function') {\n          key = await keyManager.getMasterKey();\n          console.log('Retrieved key from keyManager.getMasterKey()');\n        }\n      } catch (keyErr) {\n        console.error('Error getting key from keyManager:', keyErr);\n      }\n    }\n    \n    // As a last resort, check if key exists in the file system\n    if (!key) {\n      const keyPath = path.join(app.getPath('userData'), 'encryption.key');\n      if (fs.existsSync(keyPath)) {\n        try {\n          const keyData = fs.readFileSync(keyPath, 'utf8');\n          key = Buffer.from(keyData, 'hex');\n          console.log('Retrieved key from filesystem');\n          // Store it for future use\n          encryptionKey = key;\n        } catch (fsErr) {\n          console.error('Error reading key from filesystem:', fsErr);\n        }\n      }\n    }\n    \n    if (!key) {\n      console.error('No encryption key available');\n      return { success: false, error: 'No encryption key available. Please generate or import a key first.' };\n    }\n    \n    // If key is a hex string, convert to Buffer\n    if (typeof key === 'string') {\n      key = Buffer.from(key, 'hex');\n    }\n    \n    // Ensure key is the right length (32 bytes for AES-256)\n    if (key.length !== 32) {\n      console.error(`Invalid key length: ${key.length} bytes, expected 32 bytes`);\n      return { success: false, error: 'Invalid encryption key length.' };\n    }\n    \n    // Check if file exists\n    if (!fs.existsSync(filePath)) {\n      return { success: false, error: `File not found: ${filePath}` };\n    }\n    \n    // Read file content\n    let fileContent;\n    try {\n      fileContent = fs.readFileSync(filePath);\n    } catch (readError) {\n      console.error('Error reading file:', readError);\n      return { success: false, error: `Error reading file: ${readError.message}` };\n    }\n    \n    // Generate a random IV (Initialization Vector)\n    const iv = crypto.randomBytes(16);\n    \n    // Encrypt the file based on the selected method\n    let encryptedData, authTag;\n    \n    if (method === 'aes-256-gcm') {\n      // Use AES-256-GCM encryption\n      try {\n        const cipher = crypto.createCipheriv(method, key, iv);\n        encryptedData = Buffer.concat([cipher.update(fileContent), cipher.final()]);\n        authTag = cipher.getAuthTag(); // For AES-GCM, we need to get the authentication tag\n      } catch (encryptError) {\n        console.error('Error encrypting with AES-256-GCM:', encryptError);\n        return { success: false, error: `Encryption error: ${encryptError.message}` };\n      }\n    } else if (method === 'chacha20-poly1305' || method === 'xchacha20-poly1305') {\n      // Use ChaCha20-Poly1305 encryption\n      try {\n        const result = cryptoUtil.encryptChaCha20Poly1305(fileContent, key, iv);\n        encryptedData = result.ciphertext;\n        authTag = result.tag;\n      } catch (encryptError) {\n        console.error(`Error encrypting with ${method}:`, encryptError);\n        return { success: false, error: `Encryption error: ${encryptError.message}` };\n      }\n    } else {\n      return { success: false, error: `Unsupported encryption method: ${method}` };\n    }\n    \n    // Convert encryption method to algorithm ID for storage\n    const algorithmId = method === 'aes-256-gcm' ? 1 : \n                         method === 'chacha20-poly1305' ? 2 : \n                         method === 'xchacha20-poly1305' ? 3 : 1;\n    \n    // Prepare the encrypted file format with header\n    // Format: [Magic Bytes (2)][Version (1)][Algorithm ID (1)][IV Length (1)][Auth Tag Length (1)][IV][Auth Tag][Ciphertext]\n    const magicBytes = Buffer.from([0xF1, 0xE2]); // Magic bytes to identify our file format\n    const formatVersion = Buffer.from([0x01]); // Version 1 of our format\n    const algorithmIdBuffer = Buffer.from([algorithmId]);\n    const ivLength = Buffer.from([iv.length]);\n    const tagLength = Buffer.from([authTag.length]);\n    \n    const fullEncryptedData = Buffer.concat([\n      magicBytes,\n      formatVersion,\n      algorithmIdBuffer,\n      ivLength,\n      tagLength,\n      iv,\n      authTag,\n      encryptedData\n    ]);\n    \n    // Generate a unique ID for the file\n    const fileId = crypto.randomBytes(16).toString('hex');\n    \n    // Get original filename without path\n    const fileName = path.basename(filePath);\n    \n    // Store the encrypted file\n    const encryptedFilesDir = path.join(app.getPath('userData'), 'encrypted');\n    if (!fs.existsSync(encryptedFilesDir)) {\n      fs.mkdirSync(encryptedFilesDir, { recursive: true });\n    }\n    \n    const encryptedFilePath = path.join(encryptedFilesDir, `${fileId}_${fileName}.enc`);\n    \n    try {\n      fs.writeFileSync(encryptedFilePath, fullEncryptedData);\n    } catch (writeError) {\n      console.error('Error writing encrypted file:', writeError);\n      return { success: false, error: `Error saving encrypted file: ${writeError.message}` };\n    }\n    \n    // Store metadata about the encrypted file\n    const metadata = {\n      id: fileId,\n      originalName: fileName,\n      encryptedPath: encryptedFilePath,\n      originalSize: fileContent.length,\n      encryptedSize: fullEncryptedData.length,\n      algorithm: method,\n      timestamp: new Date().toISOString(),\n    };\n    \n    // Save metadata to a database or file\n    try {\n      const metadataPath = path.join(encryptedFilesDir, 'metadata.json');\n      let existingMetadata = [];\n      \n      if (fs.existsSync(metadataPath)) {\n        try {\n          const metadataContent = fs.readFileSync(metadataPath, 'utf8');\n          existingMetadata = JSON.parse(metadataContent);\n        } catch (parseError) {\n          console.warn('Error parsing metadata, creating new file:', parseError);\n        }\n      }\n      \n      existingMetadata.push(metadata);\n      fs.writeFileSync(metadataPath, JSON.stringify(existingMetadata, null, 2));\n    } catch (metadataError) {\n      console.warn('Error saving metadata, but encryption succeeded:', metadataError);\n    }\n    \n    console.log(`File encrypted successfully: ${encryptedFilePath}`);\n    \n    return {\n      success: true,\n      fileId,\n      fileName,\n      algorithm: method,\n      size: fileContent.length,\n      encryptedPath: encryptedFilePath\n    };\n  } catch (error) {\n    console.error('Error in encrypt-file handler:', error);\n    return { success: false, error: error.message };\n  }\n});\n\nipcMain.handle('decrypt-file', async (event, fileId, fileName) => {\n  try {\n    console.log('decrypt-file handler called with:', { fileId, fileName });\n    \n    // Input validation\n    if (!fileId) {\n      return { success: false, error: 'No file ID provided' };\n    }\n    \n    if (!fileName) {\n      return { success: false, error: 'No file name provided' };\n    }\n    \n    // Get encryption key\n    const key = await keyManager.getKey();\n    if (!key) {\n      console.error('No encryption key available');\n      return { success: false, error: 'No encryption key available' };\n    }\n    \n    // Resolve file data - try different approaches\n    let encryptedData, filePath;\n    \n    try {\n      // First approach: Use storage service\n      try {\n        const fileData = await storageService.downloadFile(fileId);\n        if (fileData && fileData.data) {\n          encryptedData = Buffer.from(fileData.data);\n          console.log(`Retrieved file data from storage service: ${encryptedData.length} bytes`);\n        }\n      } catch (storageError) {\n        console.log('Storage service lookup failed, trying file path approach:', storageError.message);\n      }\n      \n      // Second approach: Treat fileId as a path\n      if (!encryptedData && typeof fileId === 'string' && (fileId.includes('/') || fileId.includes('\\\\'))) {\n        filePath = fileId;\n        if (fs.existsSync(filePath)) {\n          encryptedData = fs.readFileSync(filePath);\n          console.log(`Read file from path ${filePath}: ${encryptedData.length} bytes`);\n        }\n      }\n      \n      // Final fallback: Try to find file by name in the encrypted files directory\n      if (!encryptedData) {\n        const encryptedDir = path.join(app.getPath('userData'), 'encrypted');\n        if (fs.existsSync(encryptedDir)) {\n          const possiblePaths = fs.readdirSync(encryptedDir)\n            .filter(item => item.includes(fileId) || item.includes(fileName));\n          \n          if (possiblePaths.length > 0) {\n            filePath = path.join(encryptedDir, possiblePaths[0]);\n            encryptedData = fs.readFileSync(filePath);\n            console.log(`Found file via directory search: ${filePath}`);\n          }\n        }\n      }\n    } catch (fsError) {\n      console.error('Error reading encrypted file:', fsError);\n      return { success: false, error: `Error reading file: ${fsError.message}` };\n    }\n    \n    // If we still don't have data, return an error\n    if (!encryptedData || encryptedData.length === 0) {\n      console.error('Could not locate or read encrypted file data');\n      return { success: false, error: 'Could not find or read encrypted file' };\n    }\n    \n    // Extract metadata - first try the modern format with headers\n    let algorithm = 'aes-256-gcm'; // Default algorithm\n    let iv, tag, ciphertext;\n    \n    try {\n      // Try to parse the file header\n      const header = encryptedData.slice(0, 2).toString('hex');\n      \n      if (header === 'f1e2') { // Magic bytes for our encrypted file format\n        const formatVersion = encryptedData[2];\n        const algorithmId = encryptedData[3];\n        \n        // Map algorithm ID to name\n        if (algorithmId === 1) {\n          algorithm = 'aes-256-gcm';\n        } else if (algorithmId === 2) {\n          algorithm = 'chacha20-poly1305';\n        }\n        \n        const ivLength = encryptedData[4];\n        const tagLength = encryptedData[5];\n        const headerLength = 6; // 2 magic bytes + 1 version + 1 algorithm + 1 ivLength + 1 tagLength\n        \n        iv = encryptedData.slice(headerLength, headerLength + ivLength);\n        tag = encryptedData.slice(headerLength + ivLength, headerLength + ivLength + tagLength);\n        ciphertext = encryptedData.slice(headerLength + ivLength + tagLength);\n        \n        console.log(`Parsed modern format: algorithm=${algorithm}, ivLength=${ivLength}, tagLength=${tagLength}`);\n      } else {\n        // Legacy format - fixed offsets\n        iv = encryptedData.slice(0, 16);\n        tag = encryptedData.slice(16, 32);\n        ciphertext = encryptedData.slice(32);\n        \n        console.log('Using legacy format with fixed offsets');\n      }\n    } catch (parseError) {\n      console.error('Error parsing encrypted data:', parseError);\n      return { success: false, error: `Error parsing encrypted data: ${parseError.message}` };\n    }\n    \n    // Now decrypt with the appropriate algorithm\n    let decryptedData;\n    try {\n      if (algorithm === 'aes-256-gcm') {\n        const decipher = crypto.createDecipheriv(algorithm, key, iv);\n        decipher.setAuthTag(tag);\n        decryptedData = Buffer.concat([\n          decipher.update(ciphertext),\n          decipher.final()\n        ]);\n      } else if (algorithm === 'chacha20-poly1305') {\n        // Use ChaCha20-Poly1305 decryption\n        decryptedData = cryptoUtil.decryptChaCha20Poly1305(ciphertext, key, iv, tag);\n      } else {\n        return { success: false, error: `Unsupported algorithm: ${algorithm}` };\n      }\n    } catch (decryptError) {\n      console.error('Error decrypting data:', decryptError);\n      return { success: false, error: `Decryption failed: ${decryptError.message}` };\n    }\n    \n    if (!decryptedData) {\n      return { success: false, error: 'Decryption produced no data' };\n    }\n    \n    // Save the decrypted file\n    const downloadsPath = app.getPath('downloads');\n    const decryptedFilePath = path.join(downloadsPath, fileName);\n    \n    try {\n      fs.writeFileSync(decryptedFilePath, decryptedData);\n      console.log(`Decrypted file saved to: ${decryptedFilePath}`);\n      \n      return {\n        success: true,\n        filePath: decryptedFilePath\n      };\n    } catch (writeError) {\n      console.error('Error writing decrypted file:', writeError);\n      return { success: false, error: `Error saving decrypted file: ${writeError.message}` };\n    }\n  } catch (error) {\n    console.error('Error in decrypt-file handler:', error);\n    return { success: false, error: error.message };\n  }\n});\n\nipcMain.handle('download-file', async (event, { fileId, fileName }) => {\n    try {\n        // Send progress updates\n        event.sender.send('download-progress', { progress: 0, status: 'Starting download...' });\n        \n        // Get encryption key\n        const encryptionKey = getEncryptionKey();\n        if (!encryptionKey) {\n            throw new Error('Encryption key not found');\n        }\n\n        // Construct storage key\n        const storageKey = `${fileId}/${fileName}.enc`;\n        const metadataKey = `${fileId}/metadata.json`;\n\n        // Try to get metadata\n        let algorithm = null;\n        try {\n            const metadataRaw = await storageService.downloadFile(metadataKey);\n            const metadata = JSON.parse(metadataRaw.toString());\n            algorithm = metadata.algorithm;\n        } catch (err) {\n            console.warn('No metadata found, assuming AES-256-GCM:', err);\n        }\n\n        // Download encrypted data\n        event.sender.send('download-progress', { progress: 25, status: 'Downloading encrypted file...' });\n        const encryptedData = await storageService.downloadFile(storageKey);\n\n        // Decrypt the data\n        event.sender.send('download-progress', { progress: 50, status: `Decrypting file with ${algorithm || 'AES-256-GCM'}...` });\n        const decryptedData = await decryptData(encryptedData, encryptionKey.toString('hex'), algorithm);\n\n        // Save the decrypted file\n        event.sender.send('download-progress', { progress: 75, status: 'Saving file...' });\n        const savePath = await dialog.showSaveDialog({\n            defaultPath: fileName,\n            filters: [{ name: 'All Files', extensions: ['*'] }]\n        });\n\n        if (savePath.canceled) {\n            return { success: false, error: 'Download cancelled' };\n        }\n\n        await fs.promises.writeFile(savePath.filePath, decryptedData);\n        event.sender.send('download-progress', { progress: 100, status: 'Download complete!' });\n\n        return { success: true };\n    } catch (err) {\n        console.error('Download error:', err);\n        return { success: false, error: err.message };\n    }\n});\n\n// Download the encrypted file without decrypting\nipcMain.handle('download-encrypted-file', async (event, { fileId, fileName }) => {\n    try {\n        // Send progress updates\n        event.sender.send('download-progress', { progress: 0, status: 'Starting download...' });\n        \n        // Construct storage key\n        const storageKey = `${fileId}/${fileName}.enc`;\n        const metadataKey = `${fileId}/metadata.json`;\n        \n        // Try to get metadata\n        let algorithm = 'unknown';\n        try {\n            const metadataRaw = await storageService.downloadFile(metadataKey);\n            const metadata = JSON.parse(metadataRaw.toString());\n            algorithm = metadata.algorithm || 'unknown';\n        } catch (err) {\n            console.warn('No metadata found:', err);\n        }\n\n        // Download encrypted data\n        event.sender.send('download-progress', { progress: 50, status: 'Downloading encrypted file...' });\n        const encryptedData = await storageService.downloadFile(storageKey);\n\n        // Save the encrypted file\n        event.sender.send('download-progress', { progress: 75, status: 'Saving file...' });\n        const savePath = await dialog.showSaveDialog({\n            defaultPath: `${fileName}.${algorithm}.encrypted`,\n            filters: [{ name: 'Encrypted Files', extensions: ['encrypted'] }]\n        });\n\n        if (savePath.canceled) {\n            return { success: false, error: 'Download cancelled' };\n        }\n\n        await fs.promises.writeFile(savePath.filePath, encryptedData);\n        event.sender.send('download-progress', { progress: 100, status: 'Download complete!' });\n\n        return { success: true };\n    } catch (err) {\n        console.error('Download error:', err);\n        return { success: false, error: err.message };\n    }\n});\n\nipcMain.handle('delete-file', async (event, fileId) => {\n  try {\n    // Get the file info from the renderer\n    const storageKey = `${fileId}/*`;\n    \n    // Find all files matching the pattern\n    const storageDir = path.join(app.getPath('userData'), 'encrypted', fileId);\n    if (fs.existsSync(storageDir)) {\n      const files = fs.readdirSync(storageDir);\n      for (const file of files) {\n        await storageService.deleteFile(`${fileId}/${file}`);\n      }\n      \n      // Remove the directory\n      fs.rmdirSync(storageDir);\n    }\n    \n    return {\n      success: true\n    };\n  } catch (error) {\n    event.sender.send('error', `Delete failed: ${error.message}`);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n});\n\n// Handle delete-encrypted-file IPC call\nipcMain.handle('delete-encrypted-file', async (event, fileId) => {\n  try {\n    console.log('delete-encrypted-file handler called for file ID:', fileId);\n    \n    // Input validation\n    if (!fileId) {\n      return { success: false, error: 'No file ID provided' };\n    }\n    \n    // Find the file in the encrypted files directory\n    const encryptedDir = path.join(app.getPath('userData'), 'encrypted');\n    let filePath = '';\n    \n    // Check if the file ID directly matches a filename\n    if (fs.existsSync(path.join(encryptedDir, fileId))) {\n      filePath = path.join(encryptedDir, fileId);\n    } else {\n      // Look for files with this ID at the beginning of their name\n      const files = fs.readdirSync(encryptedDir);\n      const matchingFile = files.find(f => f.startsWith(fileId));\n      \n      if (matchingFile) {\n        filePath = path.join(encryptedDir, matchingFile);\n      } else {\n        return { success: false, error: 'File not found' };\n      }\n    }\n    \n    // Delete the file\n    fs.unlinkSync(filePath);\n    \n    return { success: true };\n  } catch (error) {\n    console.error('Error deleting encrypted file:', error);\n    return { success: false, error: error.message };\n  }\n});\n\n// Add list-files handler after the delete-file handler (around line 352)\nipcMain.handle('list-files', async (event) => {\n  try {\n    const storageDir = path.join(app.getPath('userData'), 'encrypted');\n    \n    // Create directory if it doesn't exist\n    if (!fs.existsSync(storageDir)) {\n      fs.mkdirSync(storageDir, { recursive: true });\n      return []; // Return empty array if directory was just created\n    }\n    \n    // Get all file IDs (directories)\n    const fileIds = fs.readdirSync(storageDir).filter(item => {\n      return fs.statSync(path.join(storageDir, item)).isDirectory();\n    });\n    \n    // Get file info for each file\n    const files = [];\n    for (const fileId of fileIds) {\n      const fileDir = path.join(storageDir, fileId);\n      const fileItems = fs.readdirSync(fileDir);\n      \n      // Find the encrypted file and metadata\n      const encFile = fileItems.find(file => file.endsWith('.enc'));\n      const metadataFile = fileItems.find(file => file === 'metadata.json');\n      \n      if (encFile) {\n        let metadata = {};\n        if (metadataFile) {\n          try {\n            const metadataContent = fs.readFileSync(path.join(fileDir, metadataFile), 'utf8');\n            metadata = JSON.parse(metadataContent);\n          } catch (err) {\n            console.warn(`Error reading metadata for ${fileId}: ${err.message}`);\n          }\n        }\n        \n        // Get file stats\n        const stats = fs.statSync(path.join(fileDir, encFile));\n        \n        files.push({\n          id: fileId,\n          name: metadata.originalName || encFile.replace('.enc', ''),\n          size: stats.size,\n          date: metadata.timestamp || stats.mtime.toISOString(),\n          algorithm: metadata.algorithm || 'unknown'\n        });\n      }\n    }\n    \n    // Sort by date, newest first\n    files.sort((a, b) => new Date(b.date) - new Date(a.date));\n    \n    return files;\n  } catch (error) {\n    console.error('Error listing files:', error);\n    return [];\n  }\n});\n\n// Add entropy analysis handler\nipcMain.handle('analyze-file-entropy', async (event, fileId) => {\n  try {\n    console.log('analyze-file-entropy handler called with:', fileId);\n    \n    if (!fileId) {\n      return { success: false, error: 'No file ID provided' };\n    }\n    \n    // Get the file path instead of trying to read a directory\n    let filePath;\n    let fileBuffer;\n    \n    try {\n      // Check if the fileId is already a path\n      if (typeof fileId === 'string' && (fileId.includes('/') || fileId.includes('\\\\'))) {\n        filePath = fileId;\n        // Check if the path exists and is a file, not a directory\n        const stats = fs.statSync(filePath);\n        if (stats.isDirectory()) {\n          return { success: false, error: 'Cannot analyze a directory' };\n        }\n        fileBuffer = fs.readFileSync(filePath);\n      } else {\n        // Otherwise, try to get the file data from storage service\n        try {\n          const encryptedData = await storageService.downloadFile(fileId);\n          if (!encryptedData || !encryptedData.data) {\n            return { success: false, error: 'File not found or empty' };\n          }\n          fileBuffer = Buffer.from(encryptedData.data);\n        } catch (storageError) {\n          console.error('Storage service error:', storageError);\n          return { success: false, error: `Storage error: ${storageError.message}` };\n        }\n      }\n    } catch (fsError) {\n      console.error('File system error:', fsError);\n      return { success: false, error: fsError.message };\n    }\n    \n    if (!fileBuffer || fileBuffer.length === 0) {\n      return { success: false, error: 'File is empty' };\n    }\n    \n    // Analyze entropy in chunks\n    const analysis = entropyAnalyzer.analyzeEntropyInChunks(fileBuffer);\n    \n    console.log('Entropy analysis complete:', {\n      fileId: fileId,\n      filePath: filePath,\n      size: fileBuffer.length,\n      overallEntropy: analysis.overallEntropy,\n      rating: analysis.rating\n    });\n    \n    return {\n      success: true,\n      analysis\n    };\n  } catch (error) {\n    console.error('Error in entropy analysis:', error);\n    return { success: false, error: error.message };\n  }\n});\n\n// Add test-ipc handler\nipcMain.handle('test-ipc', async () => {\n  console.log('[main.js] test-ipc handler called');\n  return 'Test IPC successful!';\n});\n\n// Get all available encryption methods\nipcMain.handle('get-encryption-methods', () => {\n  return encryptionMethods.getAllEncryptionMethods();\n});\n\n// Get current encryption method\nipcMain.handle('get-current-encryption-method', () => {\n  return encryptionMethods.getEncryptionMethod();\n});\n\n// Set encryption method\nipcMain.handle('set-encryption-method', (event, method) => {\n  const result = encryptionMethods.setEncryptionMethod(method);\n  return {\n    success: result,\n    currentMethod: encryptionMethods.getEncryptionMethod()\n  };\n});\n\n// Function to get the encryption key, generating one if needed\nfunction getEncryptionKey() {\n  console.log('getEncryptionKey called, encryptionKey exists:', !!encryptionKey);\n  if (!encryptionKey) {\n    try {\n      // Try to get from key manager if available\n      if (keyManager && typeof keyManager.getMasterKey === 'function') {\n        console.log('Using keyManager.getMasterKey()');\n        try {\n          // The getMasterKey function returns a promise, but we need synchronous\n          // behavior for this function. Using a temporary fallback key for now.\n          encryptionKey = crypto.randomBytes(32);\n          console.log('Generated temporary key while waiting for keyManager');\n          \n          // Try to get the actual key asynchronously for next time\n          keyManager.getMasterKey().then(key => {\n            encryptionKey = key;\n            console.log('Successfully retrieved key from keyManager');\n          }).catch(err => {\n            console.error('Failed to get key from keyManager:', err);\n          });\n        } catch (keyErr) {\n          console.error('Error accessing keyManager.getMasterKey:', keyErr);\n          encryptionKey = crypto.randomBytes(32);\n        }\n        return encryptionKey;\n      } else {\n        // Generate a temporary key for the session\n        console.log('No keyManager available, generating temporary encryption key');\n        encryptionKey = crypto.randomBytes(32);\n        console.warn('Using temporary encryption key. Keys will not persist between sessions.');\n      }\n    } catch (err) {\n      console.error('Error getting encryption key:', err);\n      // Generate a temporary key if key manager fails\n      encryptionKey = crypto.randomBytes(32);\n      console.warn('Using temporary encryption key due to error. Keys will not persist between sessions.');\n    }\n  }\n  return encryptionKey;\n}\n\n// Handle check-key-status IPC call\nipcMain.handle('check-key-status', async (event) => {\n  try {\n    console.log('check-key-status handler called');\n    \n    // Try to get key from multiple sources\n    let key = global.encryptionKey;\n    let source = 'memory';\n    \n    // If no key in memory, try to get from key manager\n    if (!key && keyManager && typeof keyManager.getKey === 'function') {\n      try {\n        key = await keyManager.getKey();\n        if (key) source = 'keyManager';\n      } catch (keyErr) {\n        console.error('Error getting key from keyManager:', keyErr);\n      }\n    }\n    \n    // Check if key exists in file system as last resort\n    if (!key) {\n      const keyPath = path.join(app.getPath('userData'), 'encryption.key');\n      if (fs.existsSync(keyPath)) {\n        try {\n          const keyData = fs.readFileSync(keyPath, 'utf8');\n          key = Buffer.from(keyData, 'hex');\n          source = 'file';\n        } catch (fileErr) {\n          console.error('Error reading key file:', fileErr);\n        }\n      }\n    }\n    \n    if (key) {\n      // Generate a short ID from the key for display purposes\n      let keyId = '';\n      if (Buffer.isBuffer(key)) {\n        keyId = key.toString('hex').substring(0, 8);\n      } else if (typeof key === 'string') {\n        keyId = key.substring(0, 8);\n      }\n      \n      return {\n        exists: true,\n        keyId: keyId,\n        source: source\n      };\n    }\n    \n    return { exists: false };\n  } catch (error) {\n    console.error('Error checking key status:', error);\n    return { exists: false, error: error.message };\n  }\n});\n\n// Handle generate-key IPC call\nipcMain.handle('generate-key', async (event) => {\n  try {\n    console.log('generate-key handler called');\n    \n    // Generate a secure random key\n    const key = crypto.randomBytes(32); // 256 bits\n    \n    // Save the key in memory\n    global.encryptionKey = key;\n    \n    // Try to save to key manager if available\n    if (keyManager && typeof keyManager.setKey === 'function') {\n      try {\n        await keyManager.setKey(key);\n      } catch (keyErr) {\n        console.error('Error saving key to keyManager:', keyErr);\n      }\n    }\n    \n    // Always save to file system as backup\n    try {\n      const keyPath = path.join(app.getPath('userData'), 'encryption.key');\n      fs.writeFileSync(keyPath, key.toString('hex'), 'utf8');\n      console.log('Key saved to file system at:', keyPath);\n    } catch (fileErr) {\n      console.error('Error saving key to file system:', fileErr);\n    }\n    \n    return {\n      success: true,\n      keyId: key.toString('hex').substring(0, 8)\n    };\n  } catch (error) {\n    console.error('Error generating key:', error);\n    return { success: false, error: error.message };\n  }\n});\n\n// Handle get-encrypted-files IPC call\nipcMain.handle('get-encrypted-files', async (event) => {\n  try {\n    console.log('get-encrypted-files handler called');\n    \n    // Define the encrypted files directory\n    const encryptedDir = path.join(app.getPath('userData'), 'encrypted');\n    \n    // Create the directory if it doesn't exist\n    if (!fs.existsSync(encryptedDir)) {\n      fs.mkdirSync(encryptedDir, { recursive: true });\n      console.log('Created encrypted files directory:', encryptedDir);\n      return []; // Return empty array since no files exist yet\n    }\n    \n    // Get all files in the directory\n    const files = fs.readdirSync(encryptedDir);\n    const fileList = [];\n    \n    // Process each file to get metadata\n    for (const fileName of files) {\n      try {\n        const filePath = path.join(encryptedDir, fileName);\n        const stats = fs.statSync(filePath);\n        \n        // Skip directories and non-regular files\n        if (!stats.isFile()) continue;\n        \n        // Read metadata from file (first 1KB should contain metadata)\n        const fileBuffer = Buffer.alloc(1024);\n        const fd = fs.openSync(filePath, 'r');\n        fs.readSync(fd, fileBuffer, 0, 1024, 0);\n        fs.closeSync(fd);\n        \n        // Try to extract metadata from the file header\n        let metadata = {};\n        try {\n          // Look for JSON metadata at the beginning of the file\n          const headerStr = fileBuffer.toString('utf8', 0, 1024);\n          const metaMatch = headerStr.match(/^METADATA:(.*?)\\n/);\n          if (metaMatch && metaMatch[1]) {\n            metadata = JSON.parse(metaMatch[1]);\n          }\n        } catch (metaErr) {\n          console.log('Could not parse metadata for file:', fileName);\n        }\n        \n        // Extract file extension from original name or current name\n        const originalName = metadata.originalName || fileName;\n        const extension = path.extname(originalName).toLowerCase();\n        \n        // Generate file ID from name (or use existing if present)\n        const fileId = metadata.id || fileName.replace(/\\.[^/.]+$/, '');\n        \n        // Calculate entropy sample (first 4KB max)\n        const entropyBuffer = Buffer.alloc(Math.min(stats.size, 4096));\n        const entropyFd = fs.openSync(filePath, 'r');\n        fs.readSync(entropyFd, entropyBuffer, 0, entropyBuffer.length, 0);\n        fs.closeSync(entropyFd);\n        \n        // Calculate entropy either with analyzer or fallback\n        let entropy = 0.5; // Default midpoint\n        if (entropyAnalyzer && typeof entropyAnalyzer.calculateEntropy === 'function') {\n          entropy = entropyAnalyzer.calculateEntropy(entropyBuffer);\n        }\n        \n        fileList.push({\n          id: fileId,\n          name: metadata.originalName || fileName,\n          size: stats.size,\n          created: metadata.created || stats.birthtime.getTime(),\n          algorithm: metadata.algorithm || 'aes-256-gcm',\n          entropy: entropy,\n          extension: extension,\n          path: filePath\n        });\n      } catch (fileErr) {\n        console.error(`Error processing file ${fileName}:`, fileErr);\n      }\n    }\n    \n    console.log('Returning file list with', fileList.length, 'files');\n    return fileList;\n  } catch (error) {\n    console.error('Error getting encrypted files:', error);\n    throw error;\n  }\n});\n\n// Handle import-key IPC call\nipcMain.handle('import-key', async (event, keyData) => {\n  try {\n    console.log('import-key handler called');\n    \n    // Validate key data\n    if (!keyData) {\n      return { success: false, error: 'No key data provided' };\n    }\n    \n    // Convert to buffer if it's a hex string\n    let key;\n    if (typeof keyData === 'string') {\n      // Check if it's a valid hex string\n      if (!/^[0-9a-f]+$/i.test(keyData)) {\n        return { success: false, error: 'Invalid key format, must be hex string' };\n      }\n      \n      // Ensure key is 32 bytes (256 bits)\n      if (keyData.length !== 64) { // 32 bytes = 64 hex chars\n        return { success: false, error: 'Key must be 256 bits (32 bytes)' };\n      }\n      \n      key = Buffer.from(keyData, 'hex');\n    } else if (Buffer.isBuffer(keyData)) {\n      // Ensure key is 32 bytes (256 bits)\n      if (keyData.length !== 32) {\n        return { success: false, error: 'Key must be 256 bits (32 bytes)' };\n      }\n      \n      key = keyData;\n    } else {\n      return { success: false, error: 'Invalid key type, must be string or buffer' };\n    }\n    \n    // Save the key to memory\n    global.encryptionKey = key;\n    \n    // Try to save to key manager if available\n    if (keyManager && typeof keyManager.setKey === 'function') {\n      try {\n        await keyManager.setKey(key);\n      } catch (keyErr) {\n        console.error('Error saving key to keyManager:', keyErr);\n      }\n    }\n    \n    // Always save to file system as backup\n    try {\n      const keyPath = path.join(app.getPath('userData'), 'encryption.key');\n      fs.writeFileSync(keyPath, key.toString('hex'), 'utf8');\n    } catch (fileErr) {\n      console.error('Error saving key to file system:', fileErr);\n    }\n    \n    return {\n      success: true,\n      keyId: key.toString('hex').substring(0, 8)\n    };\n  } catch (error) {\n    console.error('Error importing key:', error);\n    return { success: false, error: error.message };\n  }\n});\n\n// Handle create-custom-key IPC call\nipcMain.handle('create-custom-key', async (event, passphrase, entropyPhrase) => {\n  try {\n    console.log('create-custom-key handler called');\n    \n    // Validate passphrases\n    if (!passphrase) {\n      return { success: false, error: 'No passphrase provided' };\n    }\n    \n    // Create a key from the passphrase using PBKDF2\n    // Use entropyPhrase as salt if provided, otherwise use a random salt\n    const salt = entropyPhrase ? \n      crypto.createHash('sha256').update(entropyPhrase).digest().slice(0, 16) : \n      crypto.randomBytes(16);\n    \n    // Derive key with 100,000 iterations (strong security)\n    const key = crypto.pbkdf2Sync(passphrase, salt, 100000, 32, 'sha256');\n    \n    // Save the key to memory\n    global.encryptionKey = key;\n    \n    // Try to save to key manager if available\n    if (keyManager && typeof keyManager.setKey === 'function') {\n      try {\n        await keyManager.setKey(key);\n      } catch (keyErr) {\n        console.error('Error saving key to keyManager:', keyErr);\n      }\n    }\n    \n    // Always save to file system as backup\n    try {\n      const keyPath = path.join(app.getPath('userData'), 'encryption.key');\n      fs.writeFileSync(keyPath, key.toString('hex'), 'utf8');\n    } catch (fileErr) {\n      console.error('Error saving key to file system:', fileErr);\n    }\n    \n    return {\n      success: true,\n      keyId: key.toString('hex').substring(0, 8)\n    };\n  } catch (error) {\n    console.error('Error creating custom key:', error);\n    return { success: false, error: error.message };\n  }\n});\n\n// Handle get-key IPC call\nipcMain.handle('get-key', async (event) => {\n  try {\n    console.log('get-key handler called');\n    \n    // Try different methods to get the key\n    let key;\n    \n    // Try the getKey method if it exists\n    if (keyManager.getKey) {\n      key = await keyManager.getKey();\n    }\n    // Try the getCurrentKey method if getKey failed or doesn't exist\n    else if (keyManager.getCurrentKey) {\n      key = await keyManager.getCurrentKey();\n    }\n    // Fallback implementation if neither method exists\n    else {\n      const keyPath = path.join(app.getPath('userData'), 'encryption.key');\n      if (fs.existsSync(keyPath)) {\n        key = fs.readFileSync(keyPath);\n      }\n    }\n    \n    if (!key) {\n      console.log('No encryption key available');\n      return null;\n    }\n    \n    // Convert the key to hex string for easier handling in the renderer\n    if (Buffer.isBuffer(key)) {\n      return key.toString('hex');\n    } else if (typeof key === 'string') {\n      // If already a string, ensure it's a valid hex string\n      return key.match(/^[0-9a-f]+$/i) ? key : Buffer.from(key).toString('hex');\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('Error in get-key handler:', error);\n    return null;\n  }\n});\n\n// Handle set-key IPC call\nipcMain.handle('set-key', async (event, keyHex) => {\n  try {\n    console.log('set-key handler called');\n    \n    encryptionKey = Buffer.from(keyHex, 'hex');\n    console.log('Key set successfully');\n    return true;\n  } catch (error) {\n    console.error('Error setting key:', error);\n    throw error;\n  }\n});\n\n// Fix the saveFileDialog handler to work with a filename parameter\nipcMain.handle('save-file-dialog', async (event, filename = 'file.txt') => {\n  const result = await dialog.showSaveDialog({\n    defaultPath: filename,\n    filters: [\n      { name: 'All Files', extensions: ['*'] }\n    ]\n  });\n  \n  if (!result.canceled) {\n    return result.filePath;\n  }\n  return null;\n});\n\nipcMain.handle('open-file-dialog', async () => {\n  console.log('open-file-dialog handler called');\n  const result = await dialog.showOpenDialog({\n    properties: ['openFile', 'multiSelections'],\n    filters: [\n      { name: 'All Files', extensions: ['*'] }\n    ]\n  });\n  \n  console.log('Dialog result:', result.canceled ? 'Canceled' : `Selected ${result.filePaths.length} files`);\n  if (!result.canceled && result.filePaths.length > 0) {\n    return result.filePaths;\n  }\n  return [];\n});\n\nipcMain.handle('save-dropped-file', async (event, fileInfo) => {\n  try {\n    // Save to temp directory since renderer can't access file paths\n    const tempDir = path.join(app.getPath('temp'), 'seamless-encryptor');\n    \n    // Create temp dir if needed\n    if (!fs.existsSync(tempDir)) {\n      fs.mkdirSync(tempDir, { recursive: true });\n    }\n    \n    // Create unique filename with timestamp\n    const timestamp = Date.now();\n    const fileName = fileInfo.name || 'file';\n    const tempFilePath = path.join(tempDir, `${timestamp}-${path.basename(fileName)}`);\n    \n    // Convert array to buffer and save\n    const buffer = Buffer.from(new Uint8Array(fileInfo.data));\n    await fs.promises.writeFile(tempFilePath, buffer);\n    \n    // Clean up temp file after 1 minute\n    setTimeout(() => {\n      try {\n        if (fs.existsSync(tempFilePath)) {\n          fs.unlinkSync(tempFilePath);\n        }\n      } catch (cleanupError) {\n        console.error('Failed to clean up temp file:', cleanupError);\n      }\n    }, 60000);\n    \n    return tempFilePath;\n  } catch (error) {\n    event.sender.send('error', `Failed to process dropped file: ${error.message}`);\n    throw error;\n  }\n});\n\n// In this file you can include the rest of your app's specific main process\n// code. You can also put them in separate files and import them here.\n\nconsole.log('[main.js] Reached end of main.js script execution.');\n\n// Create window when app is ready\napp.on('ready', () => {\n  console.log('[main.js] App ready event received.');\n  createWindow();\n});\n\n// Quit when all windows are closed, except on macOS\napp.on('window-all-closed', () => {\n  console.log('[main.js] window-all-closed event received.');\n  if (process.platform !== 'darwin') {\n    console.log('[main.js] Quitting app (platform is not macOS).');\n    app.quit();\n  } else {\n    console.log('[main.js] Not quitting app (platform is macOS).');\n  }\n});\n\n// On macOS, re-create window when dock icon is clicked and no other windows are open\napp.on('activate', () => {\n  console.log('[main.js] activate event received.');\n  if (BrowserWindow.getAllWindows().length === 0) {\n    console.log('[main.js] No windows open, calling createWindow() on activate.');\n    createWindow();\n  } else {\n    console.log('[main.js] Windows already open, not creating new window on activate.');\n  }\n});\n"],"names":[],"sourceRoot":""}